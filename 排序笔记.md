数据结构：计算机组织存储数据的方式

线性表：数组、链表

算法：作用于特定数据集上的运算流程

--------排序算法------（重要面试）

1.如何衡量一个排序算法的优劣

1.1算法的执行效率（若a能判断则不需要考虑bc的影响）

a.最好、最坏、平均时间复杂度（需三个综合来看）

b.T（n）=O（2n^2+3n+4)=O(n^2)；系数、低阶、常数（冒泡、插入）更常用插入，由于n的大小并不是足够大，因此需要考虑系数、低阶的影响。

c.比较或交换次数。

1.2算法的内存消耗：通过空间复杂度来衡量

**原地排序：特指空间复杂度为O(1)的排序算法。**

**----排序算法的稳定性----**（重要面试）

稳定性：若待排序的集合中存在值相等的元素，经过排序之后，相等元素之间原有的顺序是否改变，若未改变，则称此排序为稳定性排序。

举例：订单：金额、下单时间

300 17：00：00                300  18：00：00

301  14：00：00       ->    300 17：00：00 

300  18：00：00              301  14：00：00 

**需求：如何按照金额排序后的数据，时间也是有序的？相同金额的订单按照时间排序。**

**解决：先按照时间顺序排序一次，再按照金额进行稳定性的排序。**

稳定性排序主要用于多组数据排序（如上面金额和时间都有顺序），单个数据排序无多大意义。

2.排序分类

内部排序：排序过程无需借助外部存储器（如磁盘 排序在内存中进行），所有排序操作均在内存中完成。默认说的排序都是内部排序。

内部排序按照排序思路分为四类：

2.1插入排序法：O（n^2）

直接插入排序

时间复杂度最好O（n）最坏O（n^2）

空间复杂度O（1）

稳定性排序算法、原地排序

希尔排序

2.2选择排序O（n^2）

选择排序

堆排序

2.3交换排序

**冒泡排序**

时间复杂度O（n^2）

空间复杂度O（1）

稳定性排序

快速排序

2.4归并排序

排序算法最常用：冒泡排序、输入排序、选择排序、归并排序、计数排序、

#### 三大O（n^2）时间复杂度排序：冒泡、插入、选择

3.冒泡排序

冒泡排序只会操作相邻的两个元素，每次对相邻的两个元素做大小比较，看是否满足大小关系。**一次冒泡至少会让一个元素移动到最终位置（冒泡）**需要走n次**

举例：

排序前：4 5 6 1 2 3  按升序排序

第一次排序：4 5 1 2 3 6  截至位置array[n-1]

第二次排序：4 1 2 3 5 6   截至位置array[n-2]

第三次排序：1 2 3 4 5 6  截至位置array[n-3]

....

​                                           截至位置array[0]

优化：设置标志位，若在某次循环结束后发现没有元素交换，认为数据集已经有序，停止循环。

**算法的执行效率（时间复杂度）**

**最好情况：数据集本身就是一个有序集合O（n）（至少需要跑一遍判断是否有元素交换）**

**最坏情况：数据集完全逆序O（n^2）**

**平均情况：O（n^2）**

**算法的内存消耗：O（1），无需开辟新空间，仅仅是原有数据做交换。冒泡排序是一个原地排序算法。**

**算法稳定性：冒泡排序由于进行的是相邻元素之间大小关系变换才会交换次序，所以当两个元素大小相等时，并不会改变其相对顺序。**

```java
public class Test {
    public static void main(String[] args) {
        int[] data=new int[]{6,4,7,8,3};
        bubbleSort(data);
        for(int i:data){
            System.out.print(i+" ");
        }
    }
    public static void bubbleSort(int[] array){
        int n=array.length;
        if(n<=1){
            return;
        }
        for(int i=0;i<n;i++){
            boolean flag=false;
            for(int j=0;j<n-i-1;j++){
                if(array[j]>array[j+1]){
                    flag=true;
                    array[j]^=array[j+1];
                    array[j+1]^=array[j];
                    array[j]^=array[j+1];
                }
            }
            if(!flag){
                break;
            }
        }
    }
}
```

**4.插入排序**：基于有序集合插入思想的排序算法

直接插入排序：基于有序数组元素内容的插入得来

做题思路：（1）首先找到要插入位置；（2）将数据插入指定位置，保持整个数组的有序性。

**核心思路：将待排序的数据分为两个区间，已排序区间与待排序区间。算法刚开始时，已排序空间有一个元素，在待排序空间中选择元素与排序空间的最后一个元素比较，若比已排序的最大元素大直接放入已额排序空间最后一个位置，否则需要找到合适位置插入。**

代码实现：

```java
public class Test {
    public static void main(String[] args) {
        int[] data=new int[]{6,4,7,8,3};
        bubbleSort(data);
        for(int i:data){
            System.out.print(i+" ");
        }
    }
    public static void bubbleSort(int[] array){
        int n=array.length;
        if(n<=1){
            return;
        }
        for(int i=1;i<n;i++){
            int value=array[i];
            int j=i-1;
            //找到插入位置
            for(;j>=0;j--){
                if(value<array[j]){
                    array[j+1]=array[j];
                }else{
                    break;
                }
            }
            array[j+1]=value;
        }
    }
}

```

时间复杂度最好O（n）最坏O（n^2）

空间复杂度O（1）

稳定性算法、原地排序

#### 冒泡排序比插入排序用时少，主要是因为插入交换次数少。

外部排序：若参与排序的元素过多，数据量过大，内存放不下，需要借助外部存储器来进行排序。如桶排序。

**无论是内部排序还是外部排序，最终数据的排序一定在内存中进行。**

