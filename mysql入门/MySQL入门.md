### MySQL入门

1.数据库简介

1.1什么是数据库？

我们知道，文件可以存储数据，那么为什么还要存在数据库呢？

原因是文件存储数据存在以下问题：

(1)安全性问题；

(2)文件不利于数据的查询和管理；

(3)文件不利于存储海量数据；

(4)文件在程序中控制不方便。

**1.2数据库存储介质--由选择的存储引擎决定**

磁盘

内存

##### 1.3SQL分类

```mysql
1.DDL(Date Definition Language):数据定义语言，用于维护存储数据的结构

代表指令有:create(创建)、drop(删除)、alter(修改)
2.DML(Date Manipulation Language):数据操纵语言，用于对数据的操作
代表指令有：insert(插入)、delete(删除)、update(升级)
注意：DML中又单独分了一个DQL(Date Query Language)，数据查询语言，代表指令有：select
3.DCL(Data Control Language)：数据控制语言，主要负责权限管理和事务
代表指令有：grant(授予权限)、revoke(撤销权限)、commit(标志一个成功的隐性事务或显式事务的结束)
```

**事务：**

```mysql
1.事务概念：数据库中的事务是指逻辑上的一组操作，这组操作要么都执行成功要么全部失败回滚，不可以只执行其中一部分。
2.事务的管理：默认情况下mysql会自动管理事务，一条sql语句独占一个事务。也可以使用start transaction、rollback和commit人为方式管理。
在start transaction之后的多条语句就是一个事务，事务commit之前可以rollback。
3.在JDBC中管理事务：
connection.setAutoCommit(false);
connection.rollback();
connection.commit();
多语句时可以创建回滚点：
SavePoint sp=connection.setSavePoint();
connection.rollback(sp);
4.事务四大特性：
(1)原子性：指事务是一个不可分割的整体，事务中操作要么全部发生、要么全部失败回滚，不可以只执行其中一部分。
(2)一致性：事务处理前后数据的完整性必须保持一致。完整性是指一个数据在某个时间点完全满足数据库中约束的要求。
(3)隔离性：是指多个用户访问同一数据库时，一个用户的事务处理不能被其他用户的事务干扰，多个并发事务之间的数据要相互隔离。但实际情况中，事务相互影响的程度受到隔离级别的影响。
(4)持久性：是指事务提交后，需要将提交的事务持久化到磁盘。即使系统崩溃，提交的数据也不应该丢失。
5.其他一些概念
(1)脏读：一个事务读到另一个事务未提交的数据。
(2)不可重复读：在一个事务中多次读取某一数据的结果(一个事务读到另一个事务已经提交的数据)
(3)虚读幻读：当某个事务在读取某个范围内值得时候，另一个事务在这个范围内插入了新数据，那么之前的事务再次读取这个区间的数值时会读到新插入的数据。
6.四大隔离级别：
(1)READ UNCOMMITTED(未提交读)。在此隔离级别下，事务A对数据做的修改，即使没有提交，对于事务B来说也是可见的，产生脏读问题。这种隔离级别较低，在实际运用中会引起很多问题，不建议使用。
(2)READ COMMITTED(提交读)。在此级别下，不会出现脏读问题，但会出现不可重复读问题。
(3)REPEATABLE READ(可重复读)。在此级别下，不会出现不可重复读的问题，但会出现幻读问题，mysql默认的隔离级别为RR，InnoDB存储引擎间隙锁可解决幻读问题。事务A对数据做的修改，提交之后，对于先于事务A开启的事务是不可见的。
(4)SERIALIZABLE(可串行化)。该隔离级别是最高级别。这种隔离级别强制要求所有事物串行执行，在这种隔离级别下，读取的每行数据都加锁，会导致大量的锁征用问题，性能最差，不存在高并发问题。
7.mysql中的事务
事务的实现是基于数据库的存储引擎。不同的存储引擎对事务的支持程度不同。mysql中支持事务的存储引擎有InnoDB和NDB。InnoDB是mysql默认的存储引擎，默认的隔离级别是RR，并且在RR的隔离级别下更进一步，通过多版本并发控制(MVCC,Multiversion Concurrency Control)解决不可重复读问题，加上间隙锁(也就是并发控制)解决幻读问题。因此InnoDB的RR隔离级别实现了串行化级别的效果，而且保留了较好的并发性能。
事务的隔离性是通过锁实现，而事务的原子性、一致性和持久性则是通过事务日志实现。
事务日志：
(1)redo log
在InnoDB的存储引擎中，事务日志通过重做(redo)日志和InnoDB存储引擎的日志缓冲(InnoDB Log Buffer)实现。事务开启时，事务中的操作都会先写入存储引擎的日志缓冲中，在事务提交之前，这些缓冲日志都需要提前刷新到磁盘上持久化。事务提交后，在Buffer Pool中映射的数据文件才会慢慢刷新到磁盘。此时如果数据奔溃或宕机，那么当系统重启进行恢复时，就可以根据redo log中记录的日志，把数据库恢复到崩溃前的状态。未完成的事务，可以继续提交或回滚，这基于恢复策略而定。
在系统启动的时候，就已经为redo log分配了一块连续的存储空间，以顺序追加的方式记录redo log，通过顺序IO来改善性能。所有的事务共享redo log的存储空间，它们的redo log按语句的执行顺序，依次交替的记录在一起。
(2)undo log
undo log主要为事务的回滚服务。在事务执行的过程中，除了记录redo log，还会记录一定量的undo log。undo log记录了数据在每个操作前的状态，如果事务执行过程中需要回滚，就可以根据undo log进行回滚操作。单个事务的回滚，只会回滚当前事务做的操作，并不会影响到其他事务做的操作。
```

![1](C:\Users\14665\Desktop\mysql入门\1.png)

#####  1.4存储引擎

概念：数据库管理系统如何存储数据，如何为存储的数据建立索引和如何更新、查询数据等技术的实现方法。

查询存储引擎：

```mysql
show engines;
```

![2](C:\Users\14665\Desktop\mysql入门\2.png)

由查询结果可知Support列为YES的表示当前mysql版本所支持的存储引擎，DEFAULT表示默认存储引擎。

常用存储引擎介绍：

1.InnoDB(mysql默认存储引擎)

```mysql
1.数据库和实例
数据库：物理操作系统文件或其他形式文件类型的集合。
实例：mysql数据库由后台线程以及一个共享内存区组成。
通常情况下，两者是一对一关系；但是，在集群情况下可能存在一个数据库被多个数据实例使用的情况。
mysql实例在系统上实际上就是一个进程。
```

##### InnoDB存储架构：

![3](C:\Users\14665\Desktop\mysql入门\3.png)

##### InnoDB相关的磁盘文件：

![4](C:\Users\14665\Desktop\mysql入门\4.png)

Innodb系统表空间文件：

ibdata1存放:

(1)回滚段

(2)所有innodb表元数据信息(这就是innodb无法实现myisam表可直接将表定义文件和表数据文件拷贝到另一个库的功能，因为还有部分元数据信息在ibdata1文件中)

(3)double write,insert buffer dump等等。

##### innodb数据文件存储结构



索引组织表(聚蔟表)

根据表逻辑主键排序

数据节点每页16K

特点：

1.根据主键寻址速度很快

2.主键值递增的insert插入效率较高

3.主键值随机insert插入操作效率差

##### 因此，innodb表必须指定主键，建议使用自增数字；如果不适用主键，系统会自动加上一个6字符字符串的主键。

##### innodb数据块缓存池

1.数据的读写需要经过缓存(缓存在buffer pool即在内存中)

2.数据以整页(16K)位单位读取到缓存中

3.缓存中的数据以LRU策略换出(最少使用策略)

4.IO效率高性能好